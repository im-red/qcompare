

    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
Linux C/C++调试之二：使用strace追踪程序系统调用
2019年03月02日 18:27:42 imred 阅读数：99
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/88079459

在之前的一篇文章中，我介绍了一种调试手段：利用LD_PRELOAD机制，拦截动态链接器对动态库的符号解析，达到监控程序IO的目的。事实证明我还是太naive了，我们大可利用现成的工具——strace，来更好地完成这一项工作。

strace不只能跟踪程序IO，它能跟踪程序的所有系统调用，实现的基本手段是ptrace系统调用，不过实现细节还没研究过，今天只总结一下它的用法。

首先用strace来跟踪一下喜闻乐见的hello world：

#include <stdio.h>

int main()
{
    printf("Hello, world!\n");
    return 0;
}

    1
    2
    3
    4
    5
    6
    7

$ gcc main.c -o main
$ strace ./main

    1
    2

输出是这样的（由于太长，省略了大部分内容）：

execve("./main", ["./main"], 0x7ffcea3db620 /* 33 vars */) = 0

......(太长省略)

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8

所有系统调用被一一记录了下来，我们可以看出来，printf是通过write系统调用将字符串“Hello, world!\n”写到文件描述符为1的文件（即标准输出）中，从而输出到屏幕上的。

这就是strace最基本的用法，它还提供一些非常实用的参数，我们可以来看一下：
-e

这个参数可以用来过滤输出，它功能很多，具体可以查看strace的手册，我们只用其最基本的功能：跟踪特定的系统调用。

$ strace -e write ./main

    1

输出瞬间清爽了：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
+++ exited with 0 +++

    1
    2
    3

-k

这个参数可以用来输出堆栈，不过strace的帮助将其标记为了实验性功能。

$ strace -e write -k ./main

    1

输出为：

write(1, "Hello, world!\n", 14Hello, world!
)         = 14
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_write+0x2d) [0x8b1bd]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_do_write+0xb1) [0x8cf51]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_file_overflow+0x103) [0x8d403]
 > /lib/x86_64-linux-gnu/libc-2.27.so(_IO_puts+0x1a2) [0x80b62]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(main+0x10) [0x64a]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/imred/Documents/Workspace/playground/strace_blog/main(_start+0x2a) [0x55a]
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

-t/-tt

这组参数可以用来打印时间戳
-y

这个参数可以在打印文件描述符相关参数时同时把文件描述符对应的文件路径打印出来：

$ strace -e write -y ./main

    1

输出为：

write(1</dev/pts/0>, "Hello, world!\n", 14Hello, world!
) = 14
+++ exited with 0 +++

    1
    2
    3

可以看出来当前内容被输出到了序号为0的伪终端。

由于下面的参数与时间统计有关，所以最好调用耗时较长的系统调用来分析其作用，我使用的是usleep函数，它调用了nanosleep系统调用，代码为：

#include <unistd.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

-T

这个参数可以用来输出每个系统耗费的时间，这个时间是系统调用开始时间和结束时间之差。

$ strace -e nanosleep -T ./main

    1

输出为：

nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001089>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001078>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001972>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001108>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001139>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001091>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001093>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001326>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001029>
nanosleep({tv_sec=0, tv_nsec=1000000}, NULL) = 0 <0.001297>
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

看出来这时间统计的算不上十分准确，最大的误差甚至接近100%，不过这是strace的问题还是系统调用本身的问题并不确定，也还有可能是我使用了虚拟机的缘故。
-c

这个参数用来汇总系统调用的数据。

$ strace -c ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         1           read
  0.00    0.000000           0         2           close
  0.00    0.000000           0         8         7 stat
  0.00    0.000000           0         2           fstat
  0.00    0.000000           0         5           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0        10           nanosleep
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
  0.00    0.000000           0        10         8 openat
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

能够分析出每种系统调用总的相对时间、总的绝对时间、平均开销、调用次数、出错次数信息。

你可能会比较奇怪为什么上面汇总出来的时间消耗都是0，至少nanosleep该消耗了时间。这是因为在默认情况下统计的都是系统时间，即进程在内核空间执行代码消耗的cpu时间，而不是墙上时间。调用了nanosleep虽然消耗了用户的时间，但并没有占用多少cpu时间，所以统计出来就是0了，如果要统计墙上时间，需要下面的这个选项。
-w

这个参数指定-c参数统计墙上时间。

$ strace -wc ./main

    1

输出为：

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 97.95    0.015065        1507        10           nanosleep
  0.64    0.000098          98         1           execve
  0.38    0.000058           6        10         8 openat
  0.24    0.000037           5         8         7 stat
  0.20    0.000031           6         5           mmap
  0.18    0.000028           7         4           mprotect
  0.11    0.000017           6         3         3 access
  0.10    0.000016          16         1           munmap
  0.06    0.000009           5         2           fstat
  0.05    0.000008           4         2           close
  0.03    0.000005           5         1           read
  0.03    0.000005           5         1           brk
  0.03    0.000004           4         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.015381                    49        18 total

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

这回输出结果大致符合我们的预期了（虽然误差很大）。
-f

这个参数指定strace要跟踪从主线程衍生出来的其他线程和进程。

对于下面的程序：

#include <thread>
#include <unistd.h>

void loopSleep()
{
    for (int i = 0; i < 10; i++)
    {
        usleep(1000);
    }
}

int main()
{
    std::thread t1([](){ loopSleep(); });
    std::thread t2([](){ loopSleep(); });

    t1.join();
    t2.join();

    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

nanosleep都没有在主线程调用，如果我们直接这样调用strace的话：

$ strace -e nanosleep ./main

    1

其输出为：

+++ exited with 0 +++

    1

并没有追踪到nanosleep的调用。这时就需要指定-f参数了：

$ strace -e nanosleep -f ./main

    1

其输出为：

strace: Process 4623 attached
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000}, strace: Process 4622 attached
 <unfinished ...>
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] nanosleep({tv_sec=0, tv_nsec=1000000},  <unfinished ...>
[pid  4623] <... nanosleep resumed> NULL) = 0
[pid  4623] +++ exited with 0 +++
[pid  4622] <... nanosleep resumed> NULL) = 0
[pid  4622] +++ exited with 0 +++
+++ exited with 0 +++

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45

追踪到了我们指定的nanosleep系统调用。
-p

这个参数指定strace连接到指定进程上。

以上就是strace这把“锤子”的大致使用手册，但是如何把我们当前遇到的问题归约成“钉子”就没有手册可以参考了，需要各位各显神通了。
阅读更多 收藏 分享
用strace查找进程卡死原因

阅读数 5227

最近遇到进程卡死的情况，但是自己调试的过程中并不一定能复现，都是需要运行一段时间某些条件下才会触发，对于这种运行着不能破坏现场的情况，我们可以使用gdb-p和strace-p来跟踪。首先我们用psau... 博文
来自： Linux C/C++后台开发
linux调试工具——strace	

阅读数 56

当然C/C++的最基本的调度工具当属gdb。此处讲解一下strace用法。1、系统调用如创建文件、进程和复制文件等操作系统提供的服务，需要应用程序和操作系统之间进行交互。但是，问题在于，应用程序不能直... 博文
来自： 爱吃_宫爆鸡丁
C/C++如何判断一个程序时候进行系统调用	
05-12

现在遇到的问题就是执行一些windows程序主要是.EXE程序 但必须保证检查EXE文件时候存在非法的系统调用例如 关机、删除文件等调用。如果执行了这些调用就将进程杀掉； 关键是现在不知道如何用C或C 论坛
使用strace追踪程序的系统调用	

阅读数 1119

strace命令主要是追踪程序的系统的调用，可执行文件 helloworld由（makefile基础学习  http://blog.csdn.net/zhouzhenhe2008/article/de... 博文
来自： 烟花易冷
应用调试之使用strace命令跟踪系统调用	

阅读数 1345

一、安装：1、解压：tarxvf strace-4.5.15.tar.bz2 2、打补丁：cdstrace-4.5.15           patch-p1---是原来的文件，+++是修改后的文件，... 博文
来自： qingkongyeyue的博客
linux strace命令--跟踪系统调用	

阅读数 3743

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： jk110333的专栏
常用性能分析工具之perf，strace	

阅读数 497

﻿﻿1)Perf基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。 a）perf-stat常用统计信息： #Task... 博文
来自： qq_23032819的博客
Linux strace工具，进程诊断、排错、跟踪系统调用和信号量

阅读数 1646

Linuxstrace工具，进程诊断、排错、跟踪系统调用和信号量 博文
来自： Seandba的博客
用strace工具跟踪系统调用	

阅读数 1160

1、先解压：    strace-4.8.tar.xz 由于在ubuntu上没有装xz后缀的压缩文件的解压工具，可先直接在windows下解压　2、拷贝到服务器上去3、修改strace-4.8目录下的... 博文
来自： qingkongyeyue的博客
strace命令，跟踪系统调用以及库依赖

阅读数 1611

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： a2796749的专栏
stpeace
关注
stpeace

2397篇文章

排名:1

UsherYue
关注
UsherYue

447篇文章

排名:1000+

s1mba
关注
s1mba

255篇文章

排名:676

qingkongyeyue关注
qingkongyeyue

682篇文章

排名:2000+

strace统计程序系统调用	

阅读数 3100

在Linux中如果发现服务器的CPU消耗过大的时候，我们可以通过strace这个Linux的基础设施来检查服务器系统调用是否过多消耗服务器的资源。这个是排除掉了自己逻辑相关的一个视角来观看服务器的性能... 博文
来自： Abel's Blog
Linux strace命令---跟踪程序执行

阅读数 7415

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： 可克技术
Linux 中用 strace 追踪系统调用和信号值 （原文棒棒哒）

阅读数 6211

间接转载地址：http://www.cnblogs.com/itech/archive/2013/02/28/2937836.html     什么是strace打开manstrace，我们能看到对s... 博文
来自： stpeace的专栏
strace调试	

阅读数 1397

2012-03-23wcdj在GNU/Linux环境下，当程序出现“疑难杂症”的时候，如何快速定位问题呢？本文介绍strace/ltrace的一些使用方法，内容主要来自个人的读书笔记（可见参考文献）。... 博文
来自： linux
php-fpm生产环境下的调试strace	

阅读数 466

以前，在对php进行性能问题分析时，主要是依赖xhprof对php性能瓶颈进行分析，而这需要侵入代码。今天遇到了需要在生产环境下找出fpm问题的需求，这种情况下，在网上查找了下方案，发现了strace... 博文
来自： Gavin_new的博客
clock_gettime（系统调用）

阅读数 1262

linux中可以使用clock_gettime系统调用来获取系统时间（秒数与纳秒数）。纳秒为一秒的十亿分之一。#includeintclock_gettime(clockid_tclk_id,stru... 博文
来自： pk_20140716的专栏
通过strace和monkey测试安卓应用的系统调用	

阅读数 267

配置adb1.    下载androidstudio2.    增加系统变量https://blog.csdn.net/lxzmmd/article/details/50455671 配置x86安卓虚... 博文
来自： 每天都要元气满满
ls -l |grep "^-"|wc -l 程序问题的定位—strace -p pid(跟踪系统调用)gdb -p pid(调试)lsof -p pid(查看当前进程打开的文件描述符) ps -e

阅读数 2931

查看某文件夹下文件的个数ls-l|grep"^-"|wc-l或find./company-typef|wc-l查看某文件夹下文件的个数，包括子文件夹里的。ls-lR|grep"^-"|wc-l查看某文... 博文
来自： tycoon的专栏
用户态调测工具（一）：strace和ltrace

阅读数 334

简单科普：Linux的用户态和内核态Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件–控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用... 博文
来自： cui841923894的博客
Linux strace 命令用法详解:跟踪系统调用和信号

阅读数 895

 原文地址： http://man.linuxde.net/strace 博文
来自： 飘过的春风
程序跟踪系统调用神器之- strace	

阅读数 169

这里只是简单的提及下，所以工欲善其事必先利其器，要想很快的查找和定位问题，此工具必不可少，特别是对于底层的调用，而GDB又很难跟踪的case，具体的用法就不介绍了，网上有很多。...... 博文
来自： cddchina的专栏
强大的strace命令用法详解

阅读数 2308

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。st... 博文
来自： cs729298的博客
Android下打印调试堆栈方法总结以及strace工具使用	

阅读数 2859

打印堆栈是调试的常用方法，一般在系统异常时，我们可以将异常情况下的堆栈打印出来，这样十分方便错误查找。实际上还有另外一个非常有用的功能：分析代码的行为。android代码太过庞大复杂了，完全的静态分析... 博文
来自： sunnytina的专栏
查看系统调用和信号的命令--strace	

阅读数 903

strace命令用法调用: strace[-dffhiqrtttTvxx][-acolumn][-eexpr]... [-ofile][-ppid]...[-sstrsize][-uusername]... 博文
来自： DIYing
Strace调试详解

阅读数 590

简介strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模... 博文
来自： yangrendong的专栏
使用strace跟踪多进程程序

阅读数 2030

简介strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。常用参数-p跟踪指定的进程-ofilename默认strace将结果输出到stdout。通过-o可以将输出写入到fi... 博文
来自： IT民工的小日子
使用strace监视系统调用	

阅读数 1753

strace是一个必不可少的调试工具，strace用来监视系统调用。这个工具在系统负载非常高的时候，可以用来查看到底系统在做什么。你可以了解到系统在用户态和内核态是如何通过系统调用和信号来实现程序的功... 博文
来自： 大鹏
Linux下C编程-----文件操作(1) 通过系统调用简单操作标准输入、标准输出、标准错误

阅读数 3932

Linux的C系统调用操作 ,下面我们就来练习下简单的系统调用操作read系统调用测试/********************************************************... 博文
来自： Programmer小卫
linux环境常用的性能监控和协助开发调试工具

阅读数 4296

linux有诸多优秀的工具帮助我们分析服务器各项性能指标和协助开发调试工作。下面只列举比较基础的命令，且一般是集成在linux环境中而不需再次安装的命令。更多更详细的命令可以参考 https://gi... 博文
来自： Meditation
strace工具的实现原理

阅读数 5353

strace是Linux系统下的一个用来跟踪系统调用的工具，它的实现基础是ptrace系统调用。使用strace工具可以跟踪一个程序执行过程中发生的系统调用。... 博文
来自： 落尘纷扰的专栏
strace工具跟踪系统调用和信号

阅读数 1082

*掌握使用strace工具跟踪系统调用和信号的方法*掌握各类内存测试工具，比如memwatch（是不是和那个）*掌握使用库函数backtrace和backtrace_sysbols来定位段错误一、使用... 博文
来自： Win_cao专栏
Linux C高级编程——文件操作之系统调用	

阅读数 2784

LinuxC高级编程文件操作之系统调用宗旨：技术的学习是有限的，分享的精神的无限的！     库函数是一些完成特定功能的函数，一般由某个标准组织制作发布，并形成一定的标准。使用库函数编写的函数一般可以... 博文
来自： 血染风采2019
shell学习五十四天----进程系统调用的追踪strace	

阅读数 3114

strace前言:strace常用来跟踪进程执行时的系统调用的所接受的信号.在linux世界,进程是不能直接访问硬件设备,当进程需要访问硬件(比如读取磁盘文件,接收网络数据等等)时,必须由用户态模式切... 博文
来自： 见证大牛成长之路的专栏
linux-系统调用02-系统调用与C库函数的区别

阅读数 559

系统调用与C库函数的区别操作系统的核心是内核，内核控制系统的软硬件资源。必要时分配硬件，需要时执行软件。通过系统调用访问内核，获取想要的资源。1系统调用分类：（内核4大模块）.内存管理（cat/pro... 博文
来自： you
strace,ltrace linux下跟踪进程调用的命令

阅读数 2651

原文链接：http://zhuhaibobb.blog.163.com/blog/static/27440067201182591651723/ 本工具可以用来做大多数排除,比如mount一个NFS，... 博文
来自： Mr.pan felix的专栏
Strace诊断CPU跑高问题

阅读数 2444

手把手教你用Strace诊断问题发表于2015-10-16早些年，如果你知道有个strace命令，就很牛了，而现在大家基本都知道strace了，如果你遇到性能问题求助别人，十有八九会建议你用strac... 博文
来自： linzx0403的专栏
Linux C 库函数与系统调用的区别

阅读数 408

以下是对linux中系统调用与标准库调用的区别进行了详细的分析介绍，需要的朋友可以过来参考下1、系统调用和库函数的关系 系统调用通过软中断int0x80从用户态进入内核态。函数库中的某些函数调用了系统... 博文
来自： An1540879349的博客
使用strace,lstrace,truss来跟踪程序的运行过程

阅读数 5625

转载：http://hi.baidu.com/phps/blog/item/84c44a4a5211a22608f7efc6.html 使用truss、strace或ltrace诊断软件问题2008-... 博文
来自： 无与伦比BLOG
boss好打随便浪，元宝装备随便爆，真传奇才真的过瘾！

运维利器：万能的 strace	

阅读数 1573

strace是什么？按照strace官网的描述,strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。... 博文
来自： u012719556的专栏
【C/C++】【Linux】Linux系统调用——文件访问

阅读数 298

Linux系统调用——文件访问 函数用法 #include&amp;lt;sys/types.h&amp;gt; #include&amp;lt;sys/stat.h&amp;gt; ... 博文
来自： 乞木的博客
c/c++ linux调试工具

阅读数 2042

原文地址：http://blog.csdn.net/bugouyonggan/article/details/194839991. 使用printf调试#ifdefDEBUGPrintf(“valri... 博文
来自： 风之伤
strace-4.11 源码 12-05
strace-4.11 源码。 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等
下载
跟踪linux里的命令的系统调用strace	

阅读数 369

跟踪linux里的命令的系统调用strace 博文
来自： tiantang46800的专栏
经典传奇原版再现！无限BOSS，满屏光柱，爆率惊人

linux c语言 system系统调用与popen的使用	

阅读数 2817

system系统调用有很多诟病，很多人推荐使用popen1.popen的函数原型为：#includeFILE*popen(constchar*command,constchar*type);popen... 博文
来自： enockipp的小'码'头
Linux-（C）文件读写实例（系统调用/标准I/O库）

阅读数 7094

从实现的角度：系统调用直接对文件和设备进行访问和控制的的一组底层接口，而标准I/O库为地城I/O调用提供了一个通用的接口，系统调用直接跟底层打交道，系统调用移植性远不如标准I/O库好。从性能的角度：使... 博文
来自： 爱拼才会赢
嵌入式工具——strace	

阅读数 140

strace 博文
来自： heliangbin87的专栏
linux内核系统调用和标准C库函数的关系分析

阅读数 1万+

今天研究了一下系统调用和标准库函数的区别和联系，从网上搜集的资料如下：资料引用分割线《=========================================================... 博文
来自： 做一个有技术追求的人
利用pstack 和 strace分析程序在哪里耗时？

阅读数 5118

目前测试了nws服务器代码中的while(!stop){...}死循环，发现while循环一次有的线程需要100ms左右，这个时间就有点长了。于是利用如下linux的ps、pstack和strace对... 博文
来自： lotluck的专栏
我的天！一刀一怪，全屏掉落，神装爆不停！

【C/C++】【Linux】Linux系统调用——线程控制

阅读数 90

Linux系统调用——线程控制什么叫线程？线程是CPU调度和分派的基本单位。是比进程更小的能独立运行的基本单位。除了一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，线程基本上不拥有系统资源... 博文
来自： 乞木的博客
Linux调试工具strace和gdb常用命令小结-转

阅读数 380

Linux环境下段错误的产生原因及调试方法小结最近在Linux环境下做C语言项目，由于是在一个原有项目基础之上进行二次开发，而且项目工程庞大复杂，出现了不少问题，其中遇到最多、花费时间最长的问题就是著... 博文
来自： xp5xp6的博客
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
Objective-C培训 渗透测试教程 ReactJS课程 机器学习教程 CAVLC系数矩阵解析
ios获取idfa server的安全控制模型是什么 sql android title搜索 ios 动态修改约束 java调用系统命令学习 python调用api教程

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    C++的返回值优化（RVO，Return Value Optimization）

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

程序人生

程序人生
CSDN资讯

CSDN资讯

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护


