

    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护



    首页
    博客
    学院
    下载
    图文课
    论坛
    APP
    问答
    商城
    VIP会员
    活动
    招聘
    ITeye
    GitChat

    写博客
    小程序
    消息

原	
C++的返回值优化（RVO，Return Value Optimization）
2018年12月31日 22:51:28 imred 阅读数：150 标签： C++ RVO 更多
个人分类： C++
编辑
版权声明：转载请注明来源： https://blog.csdn.net/imred/article/details/85492788
前言

大家都知道“过早的优化是万恶之源”这句话，然而我相信其中的大多数人都不知道自己是不是在做过早的优化。我也无法准确的定义什么叫做“过早的优化”，但我相信这“过早的优化”要么是得不偿失的，要么干脆是有害无利的。今天我就想举个我认为是“过早的优化”的例子。
从函数返回值

为了从一个函数得到运行结果，常规的途径有两个：通过返回值和通过传入函数的引用或指针（当然还可以通过全局变量或成员变量，但我觉得这算不上是什么好主意）。

通过传给函数一个引用或指针来承载返回值在很多情况下是无可厚非的，毕竟有时函数需要将多个值返回给用户。除了这种情况之外，我觉得应当尽量做到参数作为函数输入，返回值作为函数输出（这不是很自然的事情吗？）。然而，我们总能看到一些“突破常规”的做法：

首先定义Message类：

struct Message
{
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

    1
    2
    3
    4
    5
    6
    7
    8
    9

为了从某个地方（比如一个队列）得到一个特定Message对象，有些人喜欢写一个这样的getMessage：

void getMessage(Message &msg); // 形式1

    1

虽然只有一个返回值，但仍然是通过传入函数的引用返回给调用者的。

为什么要这样呢？“嗯，为了提高性能。你知道，要是这样定义函数，返回Message对象时必须要构造一个临时对象，这对性能有影响。”

Message getMessage(); // 形式2

    1

我们先不讨论这带来了多少性能提升，先看看形式1相对形式2带来了哪些弊端。我认为有两点：
1. 可读性变差

略（我希望你能和我一样认为这是显而易见的）。
2. 将对象的初始化划分成了两个步骤

调用形式1时，你必然要这样：

Message msg;     // S1
getMessage(msg); // S2

    1
    2

这给维护者带来了犯错的机会：一些需要在S2语句后面对msg进行的操作有可能会被错误的放在S1和S2之间。
如果是形式2，维护者就不可能犯这种错误：

Message msg = getMessage();

    1

好，现在我们来看性能，形式2真的相对形式1性能更差吗？对于下面的代码：

#include <stdio.h>

struct Message
{
    Message()
    { 
        printf("Message::Message() is called\n"); 
    }
    Message(const Message &)
    {
        printf("Message::Message(const Message &msg) is called\n");
    }
    Message& operator=(const Message &)
    {
        printf("Message::operator=(const Message &) is called\n");
    }
    ~Message()
    {
        printf("Message::~Message() is called\n");
    }
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

Message getMessage()
{
    Message result;
    result.a = 0x11111111;

    return result;
}

int main()
{
    Message msg = getMessage();
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

你认为运行时会输出什么呢？是不是这样：

Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4

其中，第一行是临时对象result构造时打印，第二行是将临时对象赋给msg时打印，第三行是临时对象result析构时打印，第四行是msg析构时打印。

然而使用GCC 7.3.0版本使用O0（即关闭优化）编译上述代码后，运行结果为：

Message::Message() is called
Message::~Message() is called

    1
    2

并没有像预期的输出那样。

如果使用MSVC2017编译，且关闭优化（/Od），确实可以得到预期输入，但是一旦打开优化（/O2），输出就和GCC的一样了。

我们看看实际上生成了什么代码（使用GCC编译）：

(gdb) disassemble main
Dump of assembler code for function main():
   0x0000000000000776 <+0>:	push   %rbp
   0x0000000000000777 <+1>:	mov    %rsp,%rbp
   0x000000000000077a <+4>:	push   %rbx
   0x000000000000077b <+5>:	sub    $0x28,%rsp
   0x000000000000077f <+9>:	mov    %fs:0x28,%rax
   0x0000000000000788 <+18>:	mov    %rax,-0x18(%rbp)
   0x000000000000078c <+22>:	xor    %eax,%eax
   0x000000000000078e <+24>:	lea    -0x30(%rbp),%rax             #将栈上地址-0x30(%rbp)传给getMessage函数
   0x0000000000000792 <+28>:	mov    %rax,%rdi
   0x0000000000000795 <+31>:	callq  0x72a <getMessage()>
   0x000000000000079a <+36>:	mov    $0x0,%ebx
   0x000000000000079f <+41>:	lea    -0x30(%rbp),%rax
   0x00000000000007a3 <+45>:	mov    %rax,%rdi
   0x00000000000007a6 <+48>:	callq  0x7e4 <Message::~Message()>
   0x00000000000007ab <+53>:	mov    %ebx,%eax
   0x00000000000007ad <+55>:	mov    -0x18(%rbp),%rdx
   0x00000000000007b1 <+59>:	xor    %fs:0x28,%rdx
   0x00000000000007ba <+68>:	je     0x7c1 <main()+75>
   0x00000000000007bc <+70>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x00000000000007c1 <+75>:	add    $0x28,%rsp
   0x00000000000007c5 <+79>:	pop    %rbx
   0x00000000000007c6 <+80>:	pop    %rbp
   0x00000000000007c7 <+81>:	retq   
End of assembler dump.
(gdb) disassemble getMessage 
Dump of assembler code for function getMessage():
   0x000000000000072a <+0>:	push   %rbp
   0x000000000000072b <+1>:	mov    %rsp,%rbp
   0x000000000000072e <+4>:	sub    $0x20,%rsp
   0x0000000000000732 <+8>:	mov    %rdi,-0x18(%rbp)                 #将main函数传入的栈上地址保存到-0x18(%rbp)处
   0x0000000000000736 <+12>:	mov    %fs:0x28,%rax
   0x000000000000073f <+21>:	mov    %rax,-0x8(%rbp)
   0x0000000000000743 <+25>:	xor    %eax,%eax
   0x0000000000000745 <+27>:	mov    -0x18(%rbp),%rax             #将main函数传入的栈上地址传给Message::Message()函数
   0x0000000000000749 <+31>:	mov    %rax,%rdi
   0x000000000000074c <+34>:	callq  0x7c8 <Message::Message()>
   0x0000000000000751 <+39>:	mov    -0x18(%rbp),%rax
   0x0000000000000755 <+43>:	movl   $0x11111111,(%rax)
   0x000000000000075b <+49>:	nop
   0x000000000000075c <+50>:	mov    -0x18(%rbp),%rax
   0x0000000000000760 <+54>:	mov    -0x8(%rbp),%rdx
   0x0000000000000764 <+58>:	xor    %fs:0x28,%rdx
   0x000000000000076d <+67>:	je     0x774 <getMessage()+74>
   0x000000000000076f <+69>:	callq  0x5f0 <__stack_chk_fail@plt>
   0x0000000000000774 <+74>:	leaveq 
   0x0000000000000775 <+75>:	retq   
End of assembler dump.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49

可以看出来，在getMessage函数中构造的对象实际上位于main函数的栈帧上，并没有额外构造一个Message对象。这是因为开启了所谓的返回值优化（RVO，Return Value Optimization）的缘故。你想得到的效果编译器已经自动帮你完成了，你不必再牺牲什么。
RVO

对于我们这些用户来说，RVO并不是什么特别复杂的机制，主流的GCC和MSVC均支持，也没什么特别需要注意的地方。它存在的目的是优化掉不必要的拷贝复制函数的调用，即使拷贝复制函数有什么副作用，例如上面代码中的打印语句，这可能是唯一需要注意的地方了。从上面的汇编代码中可以看出来，在GCC中，其基本手段是直接将返回的对象构造在调用者栈帧上，这样调用者就可以直接访问这个对象而不必复制。

RVO是有限制条件的，在某些情况下无法进行优化，在一篇关于MSVC2005的RVO技术的文章中，提到了3点导致无法优化的情况：
1. 函数抛异常

关于这点，我是有疑问的。文章中说如果函数抛异常，开不开RVO结果都一样。如果函数抛异常，无法正常的返回，我当然不会要求编译器去做RVO了。
2. 函数可能返回具有不同变量名的对象

例如：

Message getMessage_NoRVO1(int in)
{
    Message msg1;
    msg1.a = 1;

    Message msg2;
    msg2.a = 2;

    if (in % 2)
    {
        return msg1;
    }
    else
    {
        return msg2;
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

经过验证，在GCC上确实也是这样的，拷贝构造函数被调用了。但这种情况在很多时候应该都是可以通过重构避免的。

Message::Message() is called
Message::Message() is called
Message::Message(const Message &msg) is called
Message::~Message() is called
Message::~Message() is called
Message::~Message() is called

    1
    2
    3
    4
    5
    6

3. 函数有多个出口

例如：

Message getMessage_NoRVO2(int in)
{
    Message msg;
    if (in % 2)
    {
        return msg;
    }
    msg.a = 1;
    return msg;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

这个在GCC上验证发现RVO仍然生效，查看汇编发现只有一个retq指令，多个出口被优化成一个了。

参考文档：

https://en.wikipedia.org/wiki/Copy_elision#cite_ref-moreeffcpp_6-1

https://en.cppreference.com/w/cpp/language/copy_elision

https://docs.microsoft.com/en-us/previous-versions/ms364057(v=vs.80)
详解RVO与NRVO（区别于网上常见的RVO）

4906

一直以来对RVO与NRVO以及编译器的优化操作之间的关系都不太分得清。这一次想了两天，查看了若干资料以后，总算弄清楚了。1.RVO（ReturnValueOptimization）先来看一下维基百科上...
来自： Virtual_Func
返回值优化	

阅读数 239

编译器在默认情况下，是开启了返回值优化的structA{ A(){ cout>>1"2"3" 博文
来自： liuqiuyuewo的博客
C/C++代码被 VS 2010 优化掉了，如何关闭优化？

阅读数 1万+

VS2010编译器的自动优化打碎了多少像我这样的C++新手的幻想.........现在将关闭优化方法共享下，告别那段快哭了的时代～～～... 博文
来自： Mighten Dai的ASM, C, C++的天地
关于Named Return Value（NRV）optimization－返回值优化	

阅读数 1845

首先看一下下面的程序： #include iostream>using namespace std;class A ...{public:    A()    ...{          cout  ... 博文
来自： 一刀的后院
C++返回值优化-Return Value Optimization	

阅读数 85

C++返回值优化-ReturnValueOptimizationC++中的一些小细节比较多。这里看下返回值优化。代码usingnamespacestd;classRVO{staticintcount_... 博文
来自： BetterWorld的专栏
C++编译器优化-返回值优化	

阅读数 1539

本文转自http://www.cnblogs.com/Azhu/archive/2012/07/14/2591489.html、http://www.programlife.net/cpp-retur... 博文
来自： wei.zhou的专栏
理解NRV优化	

阅读数 2142

大纲： 函数返回局部对象的拷贝的一般实现方式。 NRV（NamedReturnValue）优化。 NRV优化触发的疑问。一、函数返回局部对象的拷贝的一般实现方式比如有这么一段函数定义：classX;X... 博文
来自： 麻辣丝瓜的世界
程序的内存布局——函数调用栈的那点事-返回值优化-RVO-具名返回值优化-NRV-参数压栈

阅读数 45

[注]此文是《程序员的自我修养》的读书总结，其中掺杂着一些个人的理解，若有不对，欢迎拍砖。  程序的内存布局 现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能... 博文
来自： 随意的风的专栏
C++中的RVO优化和NRVO优化	

阅读数 68

RVO(returnvalueoptimization)和NRVO(namedreturnvalueoptimization)是C++在处理一个函数返回类对象并将返回值赋给另一个对象时，为了减少拷贝构... 博文
来自： Likes的博客
C++返回值优化RVO	

阅读数 5

返回值优化，是一种属于编译器的技术，它通过转换源代码和对象的创建来加快源代码的执行速度。RVO=returnvalueoptimization。测试平台：STM32F103VG+Keil5.15背景：... 博文
来自： weixin_34018169的博客
返回值优化RVO	

阅读数 613

返回值优化（ReturnValueOptimization，简称RVO）是一种编译器优化机制，主要是为了减少临时对象的产生。... 博文
来自： 二货磁铁
DCSnail-蜗牛
关注
DCSnail-蜗牛

225篇文章

排名:6000+

caimouse
关注
caimouse

1911篇文章

排名:23

麻辣丝瓜关注
麻辣丝瓜

8篇文章

排名:千里之外

隨意的風关注
隨意的風

256篇文章

排名:千里之外

C++优化--按值返回和返回值优化	

阅读数 2000

C++和C语言相比，最为人诟病的就是其性能问题，通常一条C语言经编译器解释后，可以固定转换成5—10条汇编语言，但是一条C++语言，就没有这么幸运了，可能会是3条汇编语言，也可能是300条。C++影响... 博文
来自： SeeSeaBee的专栏
VS2013编译器的优化怎么关
01-05

- 问答
C++中临时对象及返回值优化	

阅读数 631

转载至：http://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html                       http://www.... 博文
来自： aly1989的专栏
函数返回值的优化技术（RVO和右值引用）

阅读数 239

我们先来看一段例子，一个简单的函数返回值场景#include&amp;lt;iostream&amp;gt;usingnamespacestd;classMoveable{public:Moveabl... 博文
来自： werflychen的专栏
Named Return Value Optimization (具名返回值优化)

阅读数 3269

Normal07.8磅02falsefalsefalseEN-USZH-CNX-NONE 博文
来自： 成长之路 C++ BLOG
C语言的返回值return总结

阅读数 2430

return是C++预定义的语句，它提供了种植函数执行的一种放大。当return语句提供了一个值时，这个值就成为函数的返回值.说到return,有必要提及主函数的定义,下面是从网络上找到的资料,好好消... 博文
来自： 子寒
c语言中return返回值的用法总结

阅读数 1691

return返回值的意义就是把return&amp;lt;表达式内容&amp;gt;返回给调用return的函数。*例如： voidtest(inti,intj);{returni+j;printf(... 博文
来自： sing_Hwang的博客
C++中的返回值优化(RVO)

阅读数 299

http://www.programlife.net/cpp-return-value-optimization.html 博文
来自： songtao_yu的专栏
编译器自动优化——为什么我的C++编译器不调用拷贝构造函数了？

阅读数 391

今天在学习《深入理解C++11》中关于移动构造函数的内容时，发现了这么一个问题：#include#include#include#include#include#includeusingnamespa... 博文
来自： hiyajo_salieri的博客
C++中的返回值优化（RVO）

阅读数 2561

C++的返回值优化RVO 博文
来自： Sad_Sugar的专栏
RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)

阅读数 932

中文解释：RVO：返回值优化                   NRVO：具命返回值优化具体示例如下：#includeclassA{public: A(inti):m_a(i) { printf(... 博文
来自： diaolingle的专栏
C++ Optimization	07-17
Harriet Gecks, "Optimizing C++" Global Media | 2009 | ISBN: 9380168489 | 84 pages | PDF | 1,1 MB Int
下载
Microsoft Visual C++ Guide(在window下用vc编译wxWidget)

阅读数 5873

MicrosoftVisualC++GuideFromWxWiki(RedirectedfromMSVC)Jumpto:navigation,searchThisguideoutlinestheste... 博文
来自： cqhawk的专栏
c++返回值优化的问题

阅读数 257

本文总结以下我对返回值优化的学习，主要参考了下面这个链接的学习内容。[C++中的返回值优化（RVO）]命名返回值优化（NRVO）二话不说，先上代码：#includeclassA{public:A(){... 博文
来自： Kang_TJU的博客
C++返回值优化	

阅读数 939

当函数需要返回对象时，通常有两种写法，一种是直接在return语句中返回一个对象，一种是先构造好一个对象，然后在return中将其返回。以下代码为例：#include#includeusingname... 博文
来自： ww32cc的博客
Robot Framework通过return value实现参数在关键字间的传递

阅读数 2397

RobotFramework中returnvalue(见下图中的${query_custid})设置后，此关键字（如A）在其他关键字(如B)可以直接被引用，见下图。可以在如下关键字中直接引用上一关键字... 博文
来自： xiaoning800的博客
C++编译器优化：Copy Elision（省略不必要的拷贝）

阅读数 4896

为避免对临时对象进行不必要的拷贝，C++编译器常使用一种名为CopyEllision（拷贝去除）的优化技术，该技术至少包括以下两项内容： 返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用... 博文
来自： zwvista的专栏
RFS的web自动化验收测试——第10讲 用户关键字User Keyword（2）

阅读数 2万+

引言：什么是RFS——RobotFramework+Selenium2library，本系列主要介绍web自动化验收测试方面。（ @齐涛-道长 新浪微博） 继续介绍UserKeyword里面的Tear... 博文
来自： 老道长的测试生活
返回值与输出参数比较（return value or out parameter）

阅读数 966

函数返回处理值有两种方式，一种直接利用函数返回值返回；另一种通过输出参数返回，一般传入的值为引用或者指针。publicFooFunction1();//函数返回值的形式publicvoidFuncti... 博文
来自： awesomels的博客
delphi 取得存储过程中的返回值	

阅读数 4372

procedureTForm1.Button1Click(Sender:TObject);varx:Integer;beginwithADOStoredProc1dobeginProcedureNam... 博文
来自： easyboot的专栏
C++中函数的Named Return Value优化理解

阅读数 128

#include&amp;lt;iostream&amp;gt;usingnamespacestd;classHehe{ public: Hehe():i(0){cout&amp;lt;&amp;l... 博文
来自： qq_39422041的博客
参数返回值及NRV优化（named return value optimization）

阅读数 937

C++11中的移动构造函数又把NRV优化翻出来了，都是采用临时中间值优化，两者不能共存。参数传递如何实现？【实现模型1】引入临时对象，使用拷贝构造函数初始化。然后利用bitwisecopy将其拷贝到x... 博文
来自： hustyangju的足迹
编译器_keil的优化选项问题

阅读数 1万+

最近发现在keil编译的时候，出现莫名的问题，貌似代码有被优化掉的问题，后来查了下相关的资料，貌似懂了点。我选择的是默认的default优化方式，上网看了下，默认的是level2级别优化，最后选择le... 博文
来自： CSDN-MarkYang
c#中获取存储过程的返回值(return Value)

阅读数 2163

              stringconnStr="server=kofo;database=pubs;uid=sa;pwd=kofo123";             SqlConnectio... 博文
来自： Yao,Mane
典型粒子群优化算法（particle swarm optimization,PSO）

阅读数 6970

随着牛顿法、梯度共轭、单纯形法等传统优化方法无法满足计算需求，群智能优化算法作为现代智能计算的一类重要方法已经受到越来越多的关注。群智能优化通过模拟社会性昆虫的各种群体行为，利用群体中个体之间的信息交... 博文
来自： henghane的博客
函数的参数输入（parameter list）和返回值（return value）

阅读数 323

    在C++的世界里，语句块是封装的一种表现形式，而语句块大都以function的语法格式呈现。在使用function时，如何使得function的性能最优？可以从入参和返回值方面考量，这点是C+... 博文
来自： xunye的博客
Boost Python 包装C++函数供Python使用时返回值为引用类型的解决方案

阅读数 3609

作者：华亮    地址：http://blog.csdn.net/cedricporter我们有一段C++代码Aaaa;A&DoSomethingWithA(inta){ aaa.Set(12); r... 博文
来自： 某花
matlab学习之优化模型 --（matlab编程）-----数模

阅读数 1651

这里主要对于matlab优化工具箱进行整理linprog求解线性规划：intlinprog求解求解整数或混合整数规划。例题1：例题2例题3例题4例题5DONE！！！这里主要对于matlab优化工具箱进... 博文
来自： 默默小艺的博客
真传奇不是靠充的！装备全靠捡，0付费复古传奇！

C++ return返回值的注意

阅读数 603

在含有return语句的循环后没有提供reutrn语句是很危险的，大部分的编译器不能检测出漏洞boolstr_subrange(conststring&amp;amp;str1,consststrin... 博文
来自： 羊の博客
关于构造函数没有返回值的问题

阅读数 1557

为什么构造函数不能有返回值？摘自>  “构造函数是一种很特殊的函数，因为他没有返回值。这和‘返回值为void’有极大的差别。返回void时，一般函数并不返回任何东西，但是一般的函数能够选择是否要返回些... 博文
来自： moshansk的专栏
问题:编译策略之代码逻辑顺序不正确(Optimization Level)

阅读数 3046

曾经遇到过一个问题,运行一段代码发现执行的逻辑顺序不正确,而且在添加了其他语句后,还会有不同的顺序,但是都是不正确的.... 博文
来自： DCSnail-蜗牛
GCC优化选项详解

阅读数 2313

OptimizationinGCC原文在：http://www.linuxjournal.com/article/7269?page=0,0 博文
来自： 万里晴空
C++构造函数传参与返回值时的优化	

阅读数 337

总结C++对传参和传返回值时构造的优化处理这里用具体例子说明，简单定义一个日期类：classDate{public:Date(intyear=0,intmonth=0,intday=0):_year(... 博文
来自： Guijun6的博客
传奇十年，卸载算我输！这游戏爆率是真高！

robot framework初始化时有返回值	

阅读数 464

在初始化时需要返回值怎么处理方法一：setsuitevariable/setglobalvariable 假设执行addschoolclass会返回一个id，这个id在后面的脚本中还要使用。因为初始化... 博文
来自： weixin_42458578的博客
Optimization for Machine Learning 机器学习优化方法（英文原版） 11-30
机器学习优化方法，Optimization　for　Machine　Learning
下载
C语言return陷阱小结

阅读数 3320

1#include"stdio.h" 2  3intnum=0; 4intvalue=7; 5  6intTestFunc(void) 7{ 8  if(num==0) 9  return 10  v... 博文
来自： 小灰笔记
函数返回值存放在哪里？return到哪里？

阅读数 4920

有这么一个简单的程序：#includeusing namespace std;int func(){  int a = 1;  return a;}int main(){  int Val;  Val... 博文
来自： u013176681的专栏
斯坦福大学最优化(Optimization)教材 05-31
斯坦福大学最优化(Optimization)教材
下载
一刀一怪，一怪一神装，战力全飙升，秒天秒地秒全服！

keil优化等级设置说明

阅读数 2190

优化级别说明（仅供参考）：则其中的CodeOptimization  栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：0级... 博文
来自： 淡淡的墨痕
thymeleaf模板实现html5标签的非严格检查

阅读数 4万+

一、概述最近在springboot项目引入thymeleaf模板时，使用非严格标签时，运行会报错。默认thymeleaf模板对html5标签是严格检查的。二、在项目中加NekoHTML库在Maven中... 博文
来自： Luck_ZZ的博客
【小程序】微信小程序开发实践

阅读数 25万+

帐号相关流程注册范围 企业 政府 媒体 其他组织换句话讲就是不让个人开发者注册。 :)填写企业信息不能使用和之前的公众号账户相同的邮箱,也就是说小程序是和微信公众号一个层级的。填写公司机构信息,对公账... 博文
来自： 小雨同学的技术博客
servlet的四种响应

阅读数 5527

在一个servlet的请求中，响应的方式的通常有四式，response.getWriter()，response.getOutputStream()， request.getRequestDispa... 博文
来自： 蜗牛学习笔记
PCL环境配置失败和运行PCL自带例子

阅读数 4278

话说上次配置PCL开发环境失败； http://blog.csdn.net/bcbobo21cn/article/details/51520290 估计可能是环境变量没配置好；下面从新搞一... 博文
来自： bcbobo21cn的专栏
强连通分量及缩点tarjan算法解析

阅读数 57万+

强连通分量： 简言之 就是找环（每条边只走一次，两两可达） 孤立的一个点也是一个连通分量   使用tarjan算法 在嵌套的多个环中优先得到最大环( 最小环就是每个孤立点）   定义： int Ti... 博文
来自： 九野的博客
一文读懂反射机制

阅读数 433

注意，这篇文章因为内容太多，所以篇幅非常长。中途受不了的同学可以回到目录跳转到感兴趣的小节进行学习。   向一个门外汉介绍反射 反射入口 Class Class 的获取 通过 Obje... 博文
来自： 小小默：进无止境
人脸检测工具face_recognition的安装与应用

阅读数 4万+

人脸检测工具face_recognition的安装与应用 博文
来自： roguesir的博客
微信支付V3微信公众号支付PHP教程(thinkPHP5公众号支付)/JSSDK的使用

阅读数 14万+

扫二维码关注，获取更多技术分享 本文承接之前发布的博客《 微信支付V3微信公众号支付PHP教程/thinkPHP5公众号支付》必须阅读上篇文章后才可以阅读这篇文章。由于最近一段时间工作比较忙，... 博文
来自： Marswill
lie group and computer vision : 李群、李代数在计算机视觉中的应用

阅读数 2万+

在多视角几何中，特别是在一些恢复相机运动轨迹的模型中，我们需要将相机的旋转和平移表示出来。通常情况下，我们都是在欧几里得空间中用R和t来进行相应的运算得到相机轨迹。然而，在很多论文中，作者们却喜欢用L... 博文
来自： 知行合一
jquery/js实现一个网页同时调用多个倒计时(最新的)

阅读数 43万+

jquery/js实现一个网页同时调用多个倒计时(最新的) 最近需要网页添加多个倒计时. 查阅网络,基本上都是千遍一律的不好用. 自己按需写了个.希望对大家有用. 有用请赞一个哦! //js ... 博文
来自： Websites
WebRTC之VAD算法

阅读数 2万+

CSND已永久停更，最新版唯一来源点击下面链接跳转： 语音增强和语音识别网页书 VAD（Voice Activity Detection）算法的作用是检测语音，在远场语音交互场景中，VAD面临着两... 博文
来自： shichaog的专栏
寻找连通线,参考八后算法递归,可用于验证码去除连续干扰线

阅读数 2万+

#include using namespace std;#define M 5#define N 4int a[M][N] = {0,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,... 博文
来自： miracle的专栏
关于SpringBoot bean无法注入的问题（与文件包位置有关）

阅读数 16万+

问题场景描述整个项目通过Maven构建，大致结构如下： 核心Spring框架一个module spring-boot-base service和dao一个module server-core 提供系统... 博文
来自： 开发随笔
使用SetEnvironmentVariable调整应用程序环境变量中的path设置

阅读数 2407

在开发软件时,碰到了有一大批的dll需要加载,且这些dll中有隐式链接到其它dll情况.由于某些原因,不能将dll放入系统目录中也不能将他们放置在应用程序同一目录中. 为集中管理,将其放置到应用程序... 博文
来自： nscboy的专栏
图像处理优化 C/C++ C/C++培训 C/C++入门教程 C/C++课程
mysql关联查询两次本表 native底部 react extjs glyph 图标 java学习return java学习返回值

imred

原创
    86

粉丝
    23

喜欢
    47

评论
    37

等级：

访问：
    23万+ 

积分：
    2969 

排名：
    1万+

勋章：
联系方式
邮箱：im-red@qq.com
最新文章

    C++11中静态局部变量初始化的线程安全性
    Myer差分算法（Myer's diff algorithm）
    编辑距离算法和Levenshtein距离算法
    C++：shared_ptr的隐式转换
    Linux C/C++调试之二：使用strace追踪程序系统调用

个人分类

    C 24篇
    C++ 33篇
    Qt 20篇
    Linux 26篇
    Algorithm 5篇
    DEBUG 14篇
    MySQL 2篇
    Server 1篇
    Memo 2篇
    Low-level 8篇
    Database 6篇
    Java 1篇
    其它 8篇
    Python 2篇

展开
归档

    2019年4月 2篇
    2019年3月 3篇
    2018年12月 5篇
    2018年11月 2篇
    2018年9月 4篇
    2018年7月 3篇
    2018年6月 2篇
    2018年5月 3篇
    2018年4月 2篇
    2017年12月 1篇
    2017年10月 3篇
    2017年8月 1篇
    2017年6月 5篇
    2017年4月 1篇
    2017年1月 4篇
    2016年12月 2篇
    2016年11月 2篇
    2016年10月 2篇
    2016年9月 2篇
    2016年8月 1篇
    2016年7月 6篇
    2016年6月 1篇
    2016年4月 4篇
    2016年2月 3篇
    2016年1月 2篇
    2015年12月 6篇
    2015年11月 1篇
    2015年10月 3篇
    2015年9月 1篇
    2015年5月 5篇
    2015年4月 2篇
    2015年3月 1篇
    2014年11月 2篇
    2014年9月 1篇
    2014年5月 2篇

展开
热门文章

    前置声明与C++头文件互相包含导致的error: 'xxx' does not name a type问题

    阅读数 24902
    虚拟机中 CentOS 无法上网（connect: network is unreachable）

    阅读数 21920
    C语言：数组和指针的区别

    阅读数 18221
    redis中的5种数据结构

    阅读数 11511
    使用 uwsgi + web.py 遇到 “--no python application found, check your startup logs for errors--”

    阅读数 10983

最新评论

    Qt中QComboBox下拉列表（...

    feiyangqingyun：最终效果是改的越来越丑
    一次尝试使用cmu sphinx做...

    G165945348：要想在win10上正常运行自带的continuous样例，需要把sphinxbase和pocketsphinx都编译成release版，同时把运行库编译参数指定为：多线程DLL（/MD）。
    在Linux下实现一个使用键盘控制...

    qq_36597125：很棒，收藏研究一波~
    Qt中QTabWidget隐藏某些...

    imred：[reply]u011351682[/reply] 没有
    Qt中QTabWidget隐藏某些...

    u011351682：你好，请问你做过在QTableWidget中插入控件，并一次多选包含控件的表格吗？被选中的空间颜色也要求有区别

CSDN学院

CSDN学院
CSDN企业招聘

CSDN企业招聘

kefu@csdn.net

QQ客服

客服论坛

400-660-0108

工作时间 8:30-22:00

关于我们招聘广告服务 网站地图

百度提供站内搜索 京ICP备19004658号

©1999-2019 北京创新乐知网络技术有限公司

经营性网站备案信息
网络110报警服务

北京互联网违法和不良信息举报中心

中国互联网举报中心家长监护


